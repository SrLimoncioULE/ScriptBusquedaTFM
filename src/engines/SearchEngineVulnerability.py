import os
import re
import time
import random
import requests
from datetime import datetime
from urllib.parse import urlparse

from bs4 import BeautifulSoup
from requests.adapters import HTTPAdapter, Retry
from dotenv import load_dotenv, find_dotenv

from src.utils.Methods import Methods
from src.utils.Errors import ProviderRateLimitError, ProviderBlockedError, NetworkError


class VulnerabilitySearchEngine:
    """
    Motor de búsqueda de vulnerabilidades (NVD + MITRE/cve.org) con:
      - Sesión HTTP con reintentos
      - Rate limit por host y cooldown tras bloqueos
      - Manejo robusto de JSON/HTML y paginación
      - Excepciones al caller para guardar estado/retomar
      - Snapshots (get_state_snapshot / load_state_snapshot)

    Cambios clave (2025-08):
      - MITRE legacy (cve.mitre.org) ahora redirige a cve.org (SPA). Se añade
        whitelist de redirecciones y detección de contenido SPA para no romper.
      - NVD API 2.0 NO acepta booleanos ni comillas en keywordSearch; se sanea
        la query y se soporta 'keywordExactMatch' opcional.
    """

    def __init__(
        self,
        ia_analyzed_ids=None,
        final_results=None,
        nvd_ids=None,
        mitre_ids=None,
        log_manager=None,
    ):
        # Cargar .env (si existe)
        load_dotenv(find_dotenv(), override=False)

        # Palabra clave usada para la búsqueda actual
        self.keyword = ""

        # Motor de filtrado (años, idioma, IA, etc.)
        self.filter_engine = None

        # Conjunto de identificadores de vulnerabilidades ya analizados con modelos de IA
        self.ia_analyzed_ids = set(ia_analyzed_ids or [])

        # Diccionario con los resultados finales que han pasado todos los filtros (incluyendo IA)
        self.final_results = final_results or {}

        # Diccionario con todos los elementos recuperados de las APIs, indexados por ID
        self.raw_items = {}

        # Conjuntos con los IDs de vulnerabilidades ya procesados en cada fuente
        self.nvd_ids = set(nvd_ids or [])   # NVD
        self.mitre_ids = set(mitre_ids or [])  # MITRE

        # Contadores
        self.duplicate_count = 0
        self.num_results_bykeyword = 0
        self.log_counter = 0

        # Logger
        self.log_manager = log_manager

        self.apply_filter_ia = False
        self.values_levels_ia = {}

        # ---- Config HTTP / reintentos ----
        self.session = requests.Session()
        retries = Retry(
            total=5,
            backoff_factor=1.0,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET"],
            respect_retry_after_header=True,
        )
        self.session.mount("https://", HTTPAdapter(max_retries=retries))
        self.session.mount("http://", HTTPAdapter(max_retries=retries))

        # ---- Límites y tiempos ----
        self.timeout = 30
        self.base_sleep = 0.6
        self.max_sleep = 10
        self.cooldown_after_blocks = 2
        self.cooldown_seconds = 8 * 60  # 8 minutos

        # Min interval por host (para respetar rate limits)
        self.min_interval = {
            "services.nvd.nist.gov": 0.7,  # deja algo de margen
            "cve.mitre.org": 0.5,
        }
        self._last_req = {}
        self._block_counters = {h: 0 for h in self.min_interval.keys()}

        # ---- API Keys / headers ----
        self.NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.NVD_API_KEY = os.getenv("NVD_API_KEY") or os.getenv("NVD_API_TOKEN")  # nombres tolerantes

        self.headers_nvd = {
            "Accept": "application/json",
            "User-Agent": "VulnSearchBot/1.0",
        }
        if self.NVD_API_KEY:
            self.headers_nvd["apiKey"] = self.NVD_API_KEY
        else:
            if self.log_manager:
                self.log_manager.log_state("⚠️ [NVD] No se detectó API key; el rate-limit será más estricto.")

        self.headers_html = {
            "User-Agent": "Mozilla/5.0 (compatible; VulnSearchBot/1.0)",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        }

        # ---- Whitelist de redirecciones permitidas ----
        # cve.mitre.org → cve.org/www.cve.org (el sitio legacy está retirado)
        self.allowed_redirects = {
            "cve.mitre.org": {"www.cve.org", "cve.org"},
        }

        # ---- Snapshot para reanudar ----
        self.nvd_start_index = 0
        self.nvd_page = 0
        self.nvd_total_found = 0

        # Flag para usar coincidencia exacta de frase en NVD (si hay espacios)
        self.nvd_keyword_exact = False

    # ===================== Helpers de query =====================

    def _wrap_plain(self, t: str) -> str:
        """Envuelve en comillas si hay espacios/signos (para logs/otros motores, NO para NVD)."""
        t = (t or "").strip()
        if not t:
            return ""
        return f"\"{t}\"" if re.search(r"[^\w]", t) else t

    def _build_query_plain(self, keyword: str) -> str:
        """
        Devuelve: (keyword) AND (term1 OR term2 OR ...)
        Pensada para motores que acepten booleanos (MITRE legacy). No usar para NVD.
        """
        kw = self._wrap_plain(keyword)
        rec = [
            "CVE", "vulnerability", "exploit", "hack", "hacked",
            "hacking", "cyberattack", "malware", "ransomware", "data breach"
        ]
        or_block = " OR ".join(self._wrap_plain(t) for t in rec)
        return f"({kw}) AND ({or_block})"

    def _sanitize_for_nvd(self, s: str) -> str:
        """
        NVD 2.0 no entiende comillas ni booleanos en keywordSearch.
        - Quita comillas de borde
        - Elimina operadores booleanos y paréntesis/comillas
        - Normaliza espacios
        """
        s = (s or "").strip()
        if (len(s) >= 2) and ((s[0] == s[-1]) and s[0] in ("'", '"')):
            s = s[1:-1]
        s = re.sub(r'\b(AND|OR|NOT)\b', ' ', s, flags=re.I)
        s = re.sub(r'[()"]', ' ', s)
        s = re.sub(r'\s+', ' ', s).strip()
        return s

    # ===================== Rate limit & cooldown helpers =====================

    def _respect_rate_limit(self, host: str):
        now = time.time()
        last = self._last_req.get(host, 0.0)
        min_gap = self.min_interval.get(host, 1.0)
        wait = min_gap - (now - last)
        if wait > 0:
            time.sleep(wait)
        self._last_req[host] = time.time()

    def _note_block_and_maybe_cooldown(self, host: str):
        self._block_counters[host] = self._block_counters.get(host, 0) + 1
        if self._block_counters[host] >= self.cooldown_after_blocks:
            msg = f"[{host}] Bloqueos consecutivos. Cooldown {self.cooldown_seconds/60:.1f} min…"
            print(msg)
            if self.log_manager:
                self.log_manager.log_state(f"⏳ {msg}")
            time.sleep(self.cooldown_seconds)
            self._block_counters[host] = 0

    def _note_success(self, host: str):
        self._block_counters[host] = 0

    # ======================== Requests robustos (excepciones) ========================

    def _request_json(self, url: str, params: dict, headers: dict, source_host: str) -> dict:
        """
        GET JSON robusto con respeto de rate limit.
        Lanza:
          - ProviderRateLimitError (429)
          - ProviderBlockedError (WAF/HTML/redirect o JSON inválido)
          - NetworkError (errores de red)
        """
        try:
            self._respect_rate_limit(source_host)
            resp = self.session.get(url, params=params, headers=headers, timeout=self.timeout)

            # 429 Too Many Requests
            if resp.status_code == 429:
                ra = resp.headers.get("Retry-After")
                msg = f"[{source_host}] 429 Too Many Requests. Retry-After={ra or '—'}."
                print(msg)
                if self.log_manager:
                    self.log_manager.log_state(f"⏳ {msg}")
                self._note_block_and_maybe_cooldown(source_host)
                raise ProviderRateLimitError(msg)

            # Comprobar host/Content-Type
            ctype = (resp.headers.get("Content-Type") or "").lower()
            host = urlparse(resp.url).netloc.lower()
            if ("application/json" not in ctype) or (source_host not in host):
                sample = (resp.text or "")[:200].replace("\n", " ")
                msg = f"[{source_host}] No JSON o redirect a '{host}'. Status {resp.status_code}. Muestra: {sample}"
                print(msg)
                if self.log_manager:
                    self.log_manager.log_state(f"⚠️ {msg}")
                # reintento único tras pequeño enfriamiento
                time.sleep(min(self.base_sleep + random.uniform(0, 2), self.max_sleep))
                self._respect_rate_limit(source_host)
                resp = self.session.get(url, params=params, headers=headers, timeout=self.timeout)
                ctype = (resp.headers.get("Content-Type") or "").lower()
                host = urlparse(resp.url).netloc.lower()
                if ("application/json" not in ctype) or (source_host not in host):
                    self._note_block_and_maybe_cooldown(source_host)
                    raise ProviderBlockedError(msg)

            try:
                data = resp.json()
                self._note_success(source_host)
                return data
            except ValueError:
                sample = (resp.text or "")[:200].replace("\n", " ")
                msg = f"[{source_host}] JSON inválido. Status {resp.status_code}. Muestra: {sample}"
                print(msg)
                if self.log_manager:
                    self.log_manager.log_state(f"⚠️ {msg}")
                self._note_block_and_maybe_cooldown(source_host)
                raise ProviderBlockedError(msg)

        except requests.RequestException as e:
            raise NetworkError(f"[{source_host}] Error de red: {e}") from e

    def _request_html(self, url: str, source_host: str, params: dict | None = None) -> str:
        """
        GET HTML robusto (para MITRE/cve.org).
        Lanza ProviderBlockedError / NetworkError.
        """
        try:
            self._respect_rate_limit(source_host)
            resp = self.session.get(url, params=params, headers=self.headers_html, timeout=self.timeout)

            ctype = (resp.headers.get("Content-Type") or "").lower()
            host = urlparse(resp.url).netloc.lower()

            # Hosts permitidos tras posibles redirecciones
            allowed_hosts = {source_host}
            allowed_hosts |= self.allowed_redirects.get(source_host, set())

            if ("text/html" not in ctype) or (host not in allowed_hosts):
                sample = (resp.text or "")[:200].replace("\n", " ")
                msg = f"[{source_host}] No HTML o redirect a '{host}'. Status {resp.status_code}. Muestra: {sample}"
                print(msg)
                if self.log_manager:
                    self.log_manager.log_state(f"⚠️ {msg}")
                time.sleep(min(self.base_sleep + random.uniform(0, 2), self.max_sleep))
                # Reintento único
                self._respect_rate_limit(source_host)
                resp = self.session.get(url, params=params, headers=self.headers_html, timeout=self.timeout)
                ctype = (resp.headers.get("Content-Type") or "").lower()
                host = urlparse(resp.url).netloc.lower()

                allowed_hosts = {source_host}
                allowed_hosts |= self.allowed_redirects.get(source_host, set())

                if ("text/html" not in ctype) or (host not in allowed_hosts):
                    self._note_block_and_maybe_cooldown(source_host)
                    raise ProviderBlockedError(msg)

            self._note_success(source_host)
            return resp.text

        except requests.RequestException as e:
            raise NetworkError(f"[{source_host}] Error de red: {e}") from e

    # =========================== Modelado / merge ===========================

    def create_cve_model(self, source, cve_id, description, year, date, url):
        return {
            "ID": cve_id,
            "Source": [source],
            "Title": cve_id,
            "Summary": description or "",
            "Year": year,
            "Date": date,
            "URL": url,
            "SearchTimestamp": datetime.now().isoformat(),
        }

    def add_or_update_result(self, model: dict):
        key = model.get("ID")
        if not key:
            return
        if key in self.raw_items:
            existing = self.raw_items[key]
            src = (model.get("Source") or [""])[0]
            if src and src not in existing.get("Source", []):
                existing["Source"].append(src)
            self.duplicate_count += 1
        else:
            self.raw_items[key] = model
            self.num_results_bykeyword += 1

    # ================================ Público ================================

    def search(self, keyword):
        """
        Ejecuta la búsqueda de vulnerabilidades para una palabra clave.
        Lanza excepciones si hay problemas, para que el caller guarde estado y retome.
        """
        self.keyword = keyword
        self.num_results_bykeyword = 0
        self.log_counter = 0

        # 🔑 preparar keyword para NVD (sin comillas/booleanos) y (opcional) exact match
        nvd_kw = self._sanitize_for_nvd(keyword)
        if self.log_manager:
            self.log_manager.log_state(
                f"🔎 [NVD] keywordSearch='{nvd_kw}'"
                + (" + keywordExactMatch" if (self.nvd_keyword_exact and ' ' in nvd_kw) else "")
            )

        # NVD primero (robusto y con API)
        self._search_nvd(nvd_kw)

        try:
            self._search_mitre(keyword)
        except ProviderBlockedError as e:
            if self.log_manager:
                self.log_manager.log_state(f"🟡 [MITRE] Omitida por bloqueo/SPA: {e}")
                print(f"🟡 [MITRE] Omitida por bloqueo/SPA: {e}")

        if self.log_manager:
            self.log_manager.remove_last_states(n=self.log_counter)
            self.log_manager.log_state(
                f"🟢 Total {self.num_results_bykeyword} vulnerabilidades con la keyword: {self.keyword}"
            )

        return None

    # ================================ NVD ================================

    def _search_nvd(self, nvd_kw):
        if self.log_manager:
            self.log_manager.log_state("🟠 [NVD] Buscando…")
            self.log_counter += 1

        host = "services.nvd.nist.gov"
        results_per_page = 2000  # máximo permitido por API

        # Usar valores del snapshot si venimos de reanudar
        start_index = self.nvd_start_index
        page_num = self.nvd_page
        total_found = self.nvd_total_found

        while True:
            params = {
                "keywordSearch": nvd_kw,           # 👈 sin comillas ni booleanos
                "resultsPerPage": results_per_page,
                "startIndex": start_index,
            }
            # Coincidencia exacta de frase si procede (y hay espacios)
            if self.nvd_keyword_exact and " " in nvd_kw:
                params["keywordExactMatch"] = ""   # parámetro sin valor

            data = self._request_json(self.NVD_API_URL, params, self.headers_nvd, host)
            items = data.get("vulnerabilities", []) or []
            if not items:
                break

            page_num += 1
            if self.log_manager:
                self.log_manager.log_state(f"🟠 [NVD] Página {page_num} → {len(items)} resultados")
                self.log_counter += 1

            for it in items:
                try:
                    cve = it.get("cve", {}) or {}
                    cve_id = cve.get("id") or ""
                    if not cve_id:
                        continue

                    if cve_id in self.nvd_ids:
                        self.duplicate_count += 1
                        continue

                    # Fecha
                    date_raw = cve.get("published") or ""
                    date_norm = (date_raw.replace("Z", "+00:00") if isinstance(date_raw, str) else "")
                    year, date_str = None, None
                    if date_norm:
                        try:
                            dt = datetime.fromisoformat(date_norm)
                            year = dt.year
                            date_str = dt.strftime("%d-%m-%Y")
                        except Exception:
                            year = Methods.extract_year(cve_id)
                    if year is None:
                        year = Methods.extract_year(cve_id)

                    # Descripción EN si existe
                    descs = cve.get("descriptions", []) or []
                    description = ""
                    for d in descs:
                        if (d.get("lang") or "").lower() == "en":
                            description = d.get("value") or ""
                            break
                    if not description and descs:
                        description = descs[0].get("value") or ""

                    url = f"https://nvd.nist.gov/vuln/detail/{cve_id}"

                    model = self.create_cve_model(
                        source="NVD",
                        cve_id=cve_id,
                        year=year,
                        description=description,
                        url=url,
                        date=date_str,
                    )
                    self.add_or_update_result(model)
                    self.nvd_ids.add(cve_id)
                    total_found += 1

                except Exception as e:
                    print(f"[NVD] Item error: {e}")
                    continue

            # ¿Más páginas?
            if len(items) < results_per_page:
                break
            start_index += results_per_page

            # Actualiza snapshot continuo
            self.nvd_start_index = start_index
            self.nvd_page = page_num
            self.nvd_total_found = total_found

            # Pausa ligera
            time.sleep(min(self.base_sleep + random.uniform(0, 0.5), self.max_sleep))

        if self.log_manager:
            self.log_manager.log_state(f"🟠 [NVD] Total acumulado: {total_found} resultados")
            self.log_counter += 1

        # Guardar snapshot final también
        self.nvd_start_index = start_index
        self.nvd_page = page_num
        self.nvd_total_found = total_found

    # ================================ MITRE / CVE.ORG ================================

    def _search_mitre(self, keyword):

        if self.log_manager:
            self.log_manager.log_state(f"🟠 [MITRE] Buscando: {keyword}")
            self.log_counter += 1

        host = "cve.mitre.org"
        url = "https://cve.mitre.org/cgi-bin/cvekey.cgi"
        params = {"keyword": keyword}
        html = self._request_html(url, host, params=params)  # puede elevar excepciones

        # cve.org es SPA; si llegó aquí, verifica mensaje típico "doesn't work without JavaScript"
        spa_markers = (
            "doesn't work properly without JavaScript",
            "doesn't work without JavaScript",
            "enable it to continue",
        )
        if any(m in html for m in spa_markers):
            if self.log_manager:
                self.log_manager.log_state("🟡 [MITRE] CVE.ORG es SPA/JS. Se omite scraping, continuar con NVD.")
            self.mitre_done = True
            return

        total_found = 0

        try:
            soup = BeautifulSoup(html, "html.parser")
            rows = soup.select("table tr")
            if not rows or len(rows) < 2:
                if self.log_manager:
                    self.log_manager.log_state("🟡 [MITRE] Sin filas de resultados.")
                self.mitre_done = True
                return

            for tr in rows[1:]:
                cols = tr.find_all("td")
                if len(cols) != 2:
                    continue

                cve_id = (cols[0].get_text() or "").strip()
                description = (cols[1].get_text() or "").strip()
                if not cve_id:
                    continue

                if cve_id in self.mitre_ids:
                    self.duplicate_count += 1
                    continue

                year = Methods.extract_year(cve_id)
                date = None
                detail_url = f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"

                model = self.create_cve_model(
                    source="MITRE",
                    cve_id=cve_id,
                    year=year,
                    description=description,
                    url=detail_url,
                    date=date,
                )
                self.add_or_update_result(model)
                self.mitre_ids.add(cve_id)
                total_found += 1

            if self.log_manager:
                self.log_manager.log_state(f"🟠 [MITRE] Total acumulado: {total_found} resultados")
                self.log_counter += 1

        except Exception as e:
            # Parsing/estructura inesperada → tratar como bloqueo/problema proveedor
            raise ProviderBlockedError(f"[cve.mitre.org] Error al parsear HTML: {e}") from e
        finally:
            self.mitre_done = True  # marcar como hecho en cualquier caso

    # ============================ SNAPSHOT/RESUME ============================

    def get_state_snapshot(self) -> dict:
        return {
            "ia_analyzed_ids": list(self.ia_analyzed_ids),
            "final_results": self.final_results,
            "raw_items": self.raw_items,
            "nvd_ids": list(self.nvd_ids),
            "mitre_ids": list(self.mitre_ids),
            "duplicate_count": self.duplicate_count,
            "num_results_bykeyword": self.num_results_bykeyword,
            "apply_filter_ia": self.apply_filter_ia,
            "values_levels_ia": self.values_levels_ia,
        }

    def load_state_snapshot(self, snap: dict) -> None:
        self.ia_analyzed_ids = set(snap.get("ia_analyzed_ids", []))
        self.final_results = snap.get("final_results", {}) or {}
        self.raw_items = snap.get("raw_items", {}) or {}
        self.nvd_ids = set(snap.get("nvd_ids", []))
        self.mitre_ids = set(snap.get("mitre_ids", []))
        self.duplicate_count = snap.get("duplicate_count", 0)
        self.num_results_bykeyword = snap.get("num_results_bykeyword", 0)
        self.apply_filter_ia = snap.get("apply_filter_ia", False)
        self.values_levels_ia = snap.get("values_levels_ia", {}) or {}
