import json
import os
import requests
import time
from datetime import datetime
from bs4 import BeautifulSoup

from utils.Methods import Methods
from utils.MultiModelTagger import MultiModelTagger


# Configuraci√≥n inicial
NVD_API_URL = 'https://services.nvd.nist.gov/rest/json/cves/2.0'
NVD_API_KEY = '3bc56854-b66b-4996-9047-9c2d3c21f215'


class VulnerabilitySearchEngine:

    def __init__(self, analiced_cve_ids=None, vulnerabilities=None):
        self.analiced_cve_ids = analiced_cve_ids if analiced_cve_ids is not None else set()
        self.vulnerabilities = vulnerabilities if vulnerabilities is not None else {}
        self.keyword = ""


    def search_vulnerabilities(self, keyword):
        print(f"\nüîê Buscando vulnerabilidades para: '{keyword}'")
        self.keyword = keyword

        if self._search_nvd(keyword) == "SAVE_AND_EXIT":
            return "SAVE_AND_EXIT"
        if self._search_mitre(keyword) == "SAVE_AND_EXIT":
            return "SAVE_AND_EXIT"

        return list(self.vulnerabilities.values())


    # Metodo que busca vulnerabilidades en la base de datos nvd.
    def _search_nvd(self, keyword):
        print(f"[NVD] Buscando: {keyword}")

        results_per_page = 2000  # m√°ximo permitido por la API
        start_index = 0

        headers = {'apiKey': NVD_API_KEY}
        keywords_strict = ' AND '.join(kw.strip() for kw in keyword.split())

        while True:
            params = {
                'keywordSearch': keywords_strict,
                'resultsPerPage': results_per_page,
                'startIndex': start_index,
            }

            try:
                response = requests.get(NVD_API_URL, params=params, headers=headers)
                resp_json = response.json()
                items = resp_json.get('vulnerabilities', [])

                if not items:
                    break

                print(f"[NVD] P√°gina {start_index // results_per_page + 1} ‚Üí {len(items)} resultados")

                for item in items:
                    cve = item.get('cve', {})
                    cve_id = cve.get('id', 'CVE')
                    published_raw = cve.get('published', '')
                    description = cve.get('descriptions', [{}])[0].get('value', '')
                    year = Methods.extract_year(cve_id)

                    # Evita analizar si ya fue procesado
                    if cve_id in self.analiced_cve_ids:
                        continue

                    # Clasificaci√≥n con IA
                    #relevance = MultiModelTagger.classify_with_ensemble(cve_id, description)
                    #self.analiced_cve_ids.add(cve_id)

                    #Quitar cuando funcione la ia
                    relevance = "RELATED"
                    if relevance  == "NO_RELATED":
                        continue

                    if relevance == "SAVE_AND_EXIT":
                        print("üõë SAVE AND EXIT triggered. Saving recovery state...")
                        # Methods.save_recovery_state(keyword)
                        return "SAVE_AND_EXIT"
                    
                    if cve_id in self.vulnerabilities:
                        if "NVD" not in self.vulnerabilities[cve_id]['Source']:
                            self.vulnerabilities[cve_id]['Source'] += ", NVD"

                    else:
                        self.vulnerabilities[cve_id] = {
                            'Date': year,
                            'Source': 'NVD',
                            'Title': cve_id,
                            'URL': f"https://nvd.nist.gov/vuln/detail/{cve_id}",
                            'Description': description
                        }

                if len(items) < results_per_page:
                    break  # √∫ltima p√°gina

                start_index += results_per_page
                time.sleep(1)

            except Exception as e:
                print(f"[NVD] Error en p√°gina {start_index // results_per_page + 1}: {e}")
                break

        print(f"[NVD] Total acumulado: {len(self.vulnerabilities)} resultados\n")


    def _search_mitre(self, keyword):
        print(f"[MITRE] Buscando: {keyword}")
        url = f"https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword={keyword.replace(' ', '+')}"
        total_found = 0

        try:
            resp = requests.get(url, timeout=10)
            soup = BeautifulSoup(resp.text, 'html.parser')
            rows = soup.select('table tr')[1:]  # Ignorar encabezado

            for row in rows:
                cols = row.find_all('td')

                if len(cols) != 2:
                    continue

                
                cve_id = cols[0].text.strip()
                description = cols[1].text.strip().lower() # Descripcion en minusculas
                keyword_terms = keyword.lower().split() # Palabras de la busqueda en minusculas
                year = Methods.extract_year(cve_id)

                # Comprobamos que la descripcion contenga las palabras de la busqueda, sino descartamos resultado.
                if not all(word in description for word in keyword_terms):
                    continue

                # Evita analizar si ya fue procesado
                if cve_id in self.analiced_cve_ids:
                    continue

                # Clasificaci√≥n con IA antes de guardar
                #relevance  = MultiModelTagger.classify_with_ensemble(cve_id, description)
                #self.added_cve_ids.add(cve_id)
                #Quitar cuando funcione la ia
                relevance = "RELATED"

                if relevance == "NO_RELATED":
                    continue
                
                if relevance == "SAVE_AND_EXIT":
                    print("üõë SAVE AND EXIT triggered. Partial results will be saved.")
                    return
                
                if cve_id in self.vulnerabilities:
                    if "MITRE" not in self.vulnerabilities[cve_id]['Source']:
                        self.vulnerabilities[cve_id]['Source'] += ", MITRE"

                else:
                    self.vulnerabilities[cve_id] = {
                        'Date': year,
                        'Source': 'MITRE',
                        'Title': cve_id,
                        'URL': f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}",
                        'Description': description
                    }

                total_found += 1

            print(f"[MITRE] {total_found} resultados encontrados\n")

        except Exception as e:
            print(f"[MITRE] Error: {e}")


    def _save_recovery_state(self):
        os.makedirs("recovery", exist_ok=True)
        recovery = {
            "keyword": self.keyword,
            "added_cve_ids": list(self.added_cve_ids),
            "partial_results": list(self.vulnerabilities.values())
        }
        with open(self.recovery_path, "w", encoding="utf-8") as f:
            json.dump(recovery, f, ensure_ascii=False, indent=2)
        print(f"üíæ Estado guardado en '{self.recovery_path}'")


    def resume_from_recovery(self):
        if not os.path.exists(self.recovery_path):
            print("‚ùå No hay estado de recuperaci√≥n.")
            return []

        with open(self.recovery_path, "r", encoding="utf-8") as f:
            data = json.load(f)

        self.keyword = data["keyword"]
        self.added_cve_ids = set(data["added_cve_ids"])
        self.vulnerabilities = {item["Title"]: item for item in data["partial_results"]}

        print(f"üîÅ Reanudando b√∫squeda desde: '{self.keyword}'")
        result = self.search_vulnerabilities(self.keyword, from_resume=True)

        os.remove(self.recovery_path)
        print(f"üßπ Archivo de recuperaci√≥n eliminado.")
        return result
