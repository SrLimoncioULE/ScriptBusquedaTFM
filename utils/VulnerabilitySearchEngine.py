import requests
import time
from bs4 import BeautifulSoup

from utils.Methods import Methods
from utils.MultiModelTagger import MultiModelTagger


# Configuraci√≥n de la API
NVD_API_URL = 'https://services.nvd.nist.gov/rest/json/cves/2.0'
NVD_API_KEY = '3bc56854-b66b-4996-9047-9c2d3c21f215'


class VulnerabilitySearchEngine:
    """
    Motor de b√∫squeda de vulnerabilidades en fuentes como NVD y MITRE.
    Clasifica los resultados mediante un ensemble de modelos IA.
    """

    def __init__(self, analiced_cve_ids=None, vulnerabilities=None):
        self.analiced_cve_ids = set(analiced_cve_ids or [])
        self.vulnerabilities = vulnerabilities or {}
        self.keyword = ""


    def search(self, keyword):
        """
        Ejecuta la b√∫squeda de vulnerabilidades para una palabra clave.
        """

        self.keyword = keyword

        for source_func in [self._search_nvd, self._search_mitre]:
            result = source_func(keyword)
            if result == "SAVE_AND_EXIT":
                return "SAVE_AND_EXIT"

        return list(self.vulnerabilities.values())


    # Metodo que busca vulnerabilidades en la base de datos nvd.
    def _search_nvd(self, keyword):
        """
        Busca vulnerabilidades en la API de NVD (nist.gov).
        """

        print(f"[NVD] Buscando: {keyword}")

        results_per_page = 2000  # m√°ximo permitido por la API
        start_index = 0

        headers = {'apiKey': NVD_API_KEY}
        keywords_strict = ' AND '.join(kw.strip() for kw in keyword.split())

        while True:
            params = {
                'keywordSearch': keywords_strict,
                'resultsPerPage': results_per_page,
                'startIndex': start_index,
            }

            try:
                response = requests.get(NVD_API_URL, params=params, headers=headers)
                response.raise_for_status()
                data = response.json()
                items = data.get('vulnerabilities', [])

                if not items:
                    break

                print(f"[NVD] P√°gina {start_index // results_per_page + 1} ‚Üí {len(items)} resultados")

                for item in items:
                    cve = item.get('cve', {})
                    cve_id = cve.get('id', '')
                    published_raw = cve.get('published', '')
                    description = cve.get('descriptions', [{}])[0].get('value', '')
                    year = Methods.extract_year(cve_id)

                    # Evita analizar si ya fue procesado
                    if cve_id in self.analiced_cve_ids:
                        continue

                    # Clasificaci√≥n con IA
                    relevance = MultiModelTagger.classify_with_ensemble(cve_id, description)
                    self.analiced_cve_ids.add(cve_id)

                    if relevance  == "NO_RELATED":
                        continue

                    if relevance == "SAVE_AND_EXIT":
                        print("üõë SAVE AND EXIT triggered. Saving recovery state...")
                        # Methods.save_recovery_state(keyword)
                        return "SAVE_AND_EXIT"
                    
                    self._store_vulnerability(
                        cve_id=cve_id,
                        year=year,
                        source='NVD',
                        description=description,
                        url=f"https://nvd.nist.gov/vuln/detail/{cve_id}"
                    )

                if len(items) < results_per_page:
                    break  # √∫ltima p√°gina

                start_index += results_per_page
                time.sleep(1)

            except requests.RequestException as e:
                print(f"[NVD] Error al obtener datos: {e}")
                break

        print(f"[NVD] Total acumulado: {len(self.vulnerabilities)} resultados\n")


    def _search_mitre(self, keyword):
        """
        Busca vulnerabilidades en la web de MITRE (cve.mitre.org).
        """

        print(f"[MITRE] Buscando: {keyword}")
        url = f"https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword={keyword.replace(' ', '+')}"
        total_found = 0

        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status()

            soup = BeautifulSoup(response.text, 'html.parser')
            rows = soup.select('table tr')[1:]  # Ignorar encabezado

            keyword_terms = keyword.lower().split() # Palabras de la busqueda en minusculas
            
            for row in rows:
                cols = row.find_all('td')
                if len(cols) != 2:
                    continue

                cve_id = cols[0].text.strip()
                description = cols[1].text.strip().lower() # Descripcion en minusculas
                year = Methods.extract_year(cve_id)

                # Comprobamos que la descripcion contenga las palabras de la busqueda, sino descartamos resultado.
                if not all(term in description for term in keyword_terms):
                    continue

                # Evita analizar si ya fue procesado
                if cve_id in self.analiced_cve_ids:
                    continue

                # Clasificaci√≥n con IA antes de guardar
                relevance  = MultiModelTagger.classify_with_ensemble(cve_id, description)
                self.analiced_cve_ids.add(cve_id)

                if relevance == "NO_RELATED":
                    continue
                
                if relevance == "SAVE_AND_EXIT":
                    print("üõë SAVE AND EXIT triggered. Partial results will be saved.")
                    return "SAVE_AND_EXIT"
                
                self._store_vulnerability(
                    cve_id=cve_id,
                    year=year,
                    source='MITRE',
                    description=description,
                    url=f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
                )

                total_found += 1

            print(f"[MITRE] {total_found} resultados encontrados\n")

        except Exception as e:
            print(f"[MITRE] Error: {e}")


    def _store_vulnerability(self, cve_id, year, source, description, url):
        """
        A√±ade una vulnerabilidad a la colecci√≥n, combinando fuentes si ya existe.
        """

        if cve_id in self.vulnerabilities:
            if source not in self.vulnerabilities[cve_id]['Source']:
                self.vulnerabilities[cve_id]['Source'] += f", {source}"
        else:
            self.vulnerabilities[cve_id] = {
                'Date': year,
                'Source': source,
                'Title': cve_id,
                'URL': url,
                'Description': description
            }
